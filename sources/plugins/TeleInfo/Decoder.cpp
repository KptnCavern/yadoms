#include "stdafx.h"
#include "Decoder.h"
#include "TeleInfotrxHelpers.h"

CDecoder::CDecoder(boost::shared_ptr<yApi::IYPluginApi> api)
   : m_baseCounter(boost::make_shared<yApi::historization::CEnergy>("BaseCounter")),
     m_lowCostCounter(boost::make_shared<yApi::historization::CEnergy>("LowCostCounter")),
     m_normalCostCounter(boost::make_shared<yApi::historization::CEnergy>("NormalCostCounter")),
     m_EJPPeakPeriod(boost::make_shared<yApi::historization::CEnergy>("EJPPeakPeriod")),
     m_EJPNormalPeriod(boost::make_shared<yApi::historization::CEnergy>("EJPNormalPeriod")),
     m_tempoBlueDaysLowCostPeriod(boost::make_shared<yApi::historization::CEnergy>("TempoBlueDaysLowCostPeriod")),
     m_tempoBlueDaysNormalCostPeriod(boost::make_shared<yApi::historization::CEnergy>("TempoBlueDaysNormalCostPeriod")),
     m_tempoRedDaysLowCostPeriod(boost::make_shared<yApi::historization::CEnergy>("TempoRedDaysLowCostPeriod")),
     m_tempoRedDaysNormalCostPeriod(boost::make_shared<yApi::historization::CEnergy>("TempoRedDaysNormalCostPeriod")),
     m_tempoWhiteDaysLowCostPeriod(boost::make_shared<yApi::historization::CEnergy>("TempoWhiteDaysLowCostPeriod")),
     m_tempoWhiteDaysNormalCostPeriod(boost::make_shared<yApi::historization::CEnergy>("TempoWhiteDaysNormalCostPeriod")),
     m_instantCurrent(boost::make_shared<yApi::historization::CCurrent>("InstantCurrent")),
     m_apparentPower(boost::make_shared<yApi::historization::CApparentPower>("ApparentPower")),
     m_TimePeriod(boost::make_shared<CRunningPeriod>(api, "RunningPeriod")),
     m_ForecastPeriod(boost::make_shared<CForecastTomorrow>(api, "ForecastColor")),
     m_api(api),
     m_isdeveloperMode(false),
     m_teleinfoEnableInCounter(false),
     m_deviceCreated(false),
     m_optarif(OP_NOT_DEFINED)
{
   m_isdeveloperMode = api->getYadomsInformation()->developperMode();
}

CDecoder::~CDecoder()
{
}

void CDecoder::decodeTeleInfoMessage(boost::shared_ptr<yApi::IYPluginApi> api,
                                     const boost::shared_ptr<std::map<std::string, std::string>>& messages)
{
   m_teleinfoEnableInCounter = (messages->size() == 1 && messages->find(TE_ADCO) != messages->end()) ? false : true;

   for (const auto message : *messages)
   {
      processMessage(message.first,
                     message.second);
   }

   if (!m_deviceCreated)
      createDeviceAndKeywords(messages->find(TE_PAPP) != messages->end());

   m_api->historizeData(m_deviceName, m_keywords);
}

void CDecoder::createDeviceAndKeywords(bool apparentPowerPresent)
{
   //Add the apparent power if this frame is detected. This frame is not automatically generated by all counters
   if (apparentPowerPresent)
      m_keywords.push_back(m_apparentPower);

   if (m_isdeveloperMode) std::cout << "Nb keywords : " << "=" << m_keywords.size() << std::endl;

   if (!isERDFCounterDesactivated())
   {
      m_api->declareDevice(m_deviceName,
                           "TeleInfoUSB : Id = " + m_deviceName,
                           m_keywords,
                           m_DeviceDetails);
   }

   m_deviceCreated = true;
}

void CDecoder::createKeywordList(const std::string& tariff)
{
   switch (tariff[1])
   {
   case 'A':
   {
      m_optarif = OP_BASE;

      m_keywords.clear();
      m_keywords.push_back(m_baseCounter);
      m_keywords.push_back(m_instantCurrent);
      m_keywords.push_back(m_TimePeriod->GetHistorizable());
      break;
   }
   case 'C':
   {
      m_optarif = OP_CREUSE;

      m_keywords.clear();
      m_keywords.push_back(m_lowCostCounter);
      m_keywords.push_back(m_normalCostCounter);
      m_keywords.push_back(m_instantCurrent);
      m_keywords.push_back(m_TimePeriod->GetHistorizable());
      break;
   }
   case 'J':
   {
      m_optarif = OP_EJP;

      m_keywords.clear();
      m_keywords.push_back(m_EJPPeakPeriod);
      m_keywords.push_back(m_EJPNormalPeriod);
      m_keywords.push_back(m_instantCurrent);
      m_keywords.push_back(m_TimePeriod->GetHistorizable());
      break;
   }
   case 'B':
   {
      m_optarif = OP_TEMPO;

      m_keywords.clear();
      m_keywords.push_back(m_tempoBlueDaysLowCostPeriod);
      m_keywords.push_back(m_tempoBlueDaysNormalCostPeriod);
      m_keywords.push_back(m_tempoRedDaysLowCostPeriod);
      m_keywords.push_back(m_tempoRedDaysNormalCostPeriod);
      m_keywords.push_back(m_tempoWhiteDaysLowCostPeriod);
      m_keywords.push_back(m_tempoWhiteDaysNormalCostPeriod);
      m_keywords.push_back(m_instantCurrent);
      m_keywords.push_back(m_TimePeriod->GetHistorizable());
      m_keywords.push_back(m_ForecastPeriod->GetHistorizable());
      break;
   }
   default:
      //Erreur normalement
      break;
   }
}

bool CDecoder::isERDFCounterDesactivated() const
{
   return !m_teleinfoEnableInCounter;
}

void CDecoder::processMessage(const std::string& key,
                                  const std::string& value)
{
	try
	{
		if (key == TE_ADCO)
		{
			if (m_isdeveloperMode) std::cout << "ADCO" << "=" << value << std::endl;

			static bool ADCOalreadyReceived = false;

			if (!ADCOalreadyReceived)
			{
				m_deviceName = value;
				ADCOalreadyReceived = true;
			}
		}
		else if (key == TE_OPTARIF)
		{
			if (m_isdeveloperMode) std::cout << "OPTARIF" << "=" << value << std::endl;
			if (m_keywords.empty())
				createKeywordList(value);
		}
		else if (key == TE_ISOUSC)
		{
			if (m_isdeveloperMode) std::cout << "ISOUSC" << "=" << value << std::endl;
		}
		else if (key == TE_BASE)
		{
			if (m_isdeveloperMode) std::cout << "BASE" << "=" << value << std::endl;
			m_baseCounter->set(std::stoll(value));
		}
		else if (key == TE_HCHC)
		{
			if (m_isdeveloperMode) std::cout << "HCHC" << "=" << value << std::endl;
			m_lowCostCounter->set(std::stoll(value));
		}
		else if (key == TE_HCHP)
		{
			if (m_isdeveloperMode) std::cout << "HCHP" << "=" << value << std::endl;
			m_normalCostCounter->set(std::stoll(value));
		}
		else if (key == TE_EJPHPM)
		{
			if (m_isdeveloperMode) std::cout << "EJPHPM" << "=" << value << std::endl;
			m_EJPPeakPeriod->set(std::stoll(value));
		}
		else if (key == TE_EJPHN)
		{
			if (m_isdeveloperMode) std::cout << "EJPHN" << "=" << value << std::endl;
			m_EJPNormalPeriod->set(std::stoll(value));
		}
		else if (key == TE_BBRHCJB)
		{
			if (m_isdeveloperMode) std::cout << "BBRHCJB" << "=" << value << std::endl;
			m_tempoBlueDaysLowCostPeriod->set(std::stoll(value));
		}
		else if (key == TE_BBRHPJB)
		{
			if (m_isdeveloperMode) std::cout << "BBRHPJB" << "=" << value << std::endl;
			m_tempoBlueDaysNormalCostPeriod->set(std::stoll(value));
		}
		else if (key == TE_BBRHCJW)
		{
			if (m_isdeveloperMode) std::cout << "BBRHCJW" << "=" << value << std::endl;
			m_tempoWhiteDaysLowCostPeriod->set(std::stoll(value));
		}
		else if (key == TE_BBRHPJW)
		{
			if (m_isdeveloperMode) std::cout << "BBRHPJW" << "=" << value << std::endl;
			m_tempoWhiteDaysNormalCostPeriod->set(std::stoll(value));
		}
		else if (key == TE_BBRHCJR)
		{
			if (m_isdeveloperMode) std::cout << "BBRHCJR" << "=" << value << std::endl;
			m_tempoRedDaysLowCostPeriod->set(std::stoll(value));
		}
		else if (key == TE_BBRHPJR)
		{
			if (m_isdeveloperMode) std::cout << "BBRHPJR" << "=" << value << std::endl;
			m_tempoRedDaysNormalCostPeriod->set(std::stoll(value));
		}
		else if (key == TE_PTEC)
		{
			if (m_isdeveloperMode) std::cout << "PTEC" << "=" << value << std::endl;
			m_TimePeriod->set(value);
		}
		else if (key == TE_IINST)
		{
			if (m_isdeveloperMode) std::cout << "IINST" << "=" << value << std::endl;
			m_instantCurrent->set(std::stod(value));
		}
		else if (key == TE_IMAX)
		{
			if (m_isdeveloperMode) std::cout << "IMAX" << "=" << value << std::endl;
		}
		else if (key == TE_PAPP)
		{
			if (m_isdeveloperMode) std::cout << "PAPP" << "=" << value << std::endl;
			m_apparentPower->set(std::stol(value));
		}
		else if (key == TE_HHPHC)
		{
			//No interest ! Used by the distributor.
			if (m_isdeveloperMode) std::cout << "HHPHC" << "=" << value << std::endl;
		}
		else if (key == TE_DEMAIN)
		{
			if (m_isdeveloperMode) std::cout << "DEMAIN" << "=" << value << std::endl;
			m_ForecastPeriod->set(value);
		}
		else if (key == TE_ADPS)
		{
			// Threshold warning ! If IINST > ISOUSC
			if (m_isdeveloperMode) std::cout << "ADPS" << "=" << value << std::endl;
		}
		else if (key == TE_MOTDETAT)
		{
			// This value is for the distributor. It's nevers used
			if (m_isdeveloperMode) std::cout << "MOTDETAT" << "=" << value << std::endl;
		}
		else
		{
			std::cerr << "label " << key << " not processed" << std::endl;
		}
	}
	catch (std::exception& e )
	{
		std::cerr << "Exception received !" << e.what() << std::endl;
	}
}